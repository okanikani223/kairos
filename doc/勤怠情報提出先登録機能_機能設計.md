# 勤怠情報提出先登録機能 機能設計

<!-- ドキュメント情報 -->
**作成日**: 2025/06/08  
**最終更新**: 2025/06/09  
**バージョン**: 1.1  
**担当者**: カーン  
**レビュー状況**: レビュー中  

## 関連文書
- [勤怠情報提出先取得機能_機能設計.md](./勤怠情報提出先取得機能_機能設計.md)
- [勤怠情報提出先更新機能_機能設計.md](./勤怠情報提出先更新機能_機能設計.md)
- [勤怠情報提出先削除機能_機能設計.md](./勤怠情報提出先削除機能_機能設計.md)
- [ドキュメント構造統一標準.md](./ドキュメント構造統一標準.md)

## 1. 機能概要

### 1.1 機能の目的・背景

勤怠情報提出先登録機能は、新しい勤怠情報提出先（会社・組織）をシステムに登録するためのAPIです。複数の勤務先を持つユーザーが、それぞれの提出先の勤務条件や規定時間を個別に管理できるようにします。

**主要目的**：
- 新規提出先の効率的な登録
- 勤務条件・規定時間の設定
- 位置情報ベースの勤怠管理基盤構築
- 複数提出先の個別管理

### 1.2 機能スコープ

**対象範囲**：
- 提出先基本情報の登録
- 規定勤務時間の設定
- 位置情報の設定
- 所属期間の設定
- バリデーション・重複チェック

**除外範囲**：
- 登録済み提出先の更新機能
- 他ユーザーの提出先への参照
- 提出先の一括登録機能
- 提出先情報のインポート機能

### 1.3 前提条件・制約事項

**前提条件**：
- 適切な認証・認可が行われていること
- ユーザーが登録権限を有すること
- 必須項目が適切に入力されていること

**制約事項**：
- 1ユーザーあたり最大20提出先まで
- 会社名は同一ユーザー内で重複不可
- 位置情報は必須項目
- 開始時刻 < 終了時刻の時間整合性必須

## 2. 要件・制約事項

### 2.1 機能要件

#### 2.1.1 登録処理
- **基本情報登録**: 会社名、位置情報の必須登録
- **時間設定**: 規定勤務時間、休憩時間の設定
- **期間設定**: 所属開始日、終了日の設定
- **自動生成**: 一意ID、タイムスタンプの自動設定

#### 2.1.2 データ検証
- 入力値の形式・範囲チェック
- 重複データの検出・防止
- 業務ルールの適用
- 整合性チェック

#### 2.1.3 レスポンス制御
- 登録成功時の詳細情報返却
- エラー時の適切なメッセージ提供
- 作成リソースへのリンク提供

### 2.2 非機能要件

#### 2.2.1 性能要件
- レスポンス時間: 1秒以内
- 同時登録処理: 50ユーザー
- データ一意性の確保

#### 2.2.2 可用性要件
- 稼働率: 99.9%
- 障害復旧時間: 4時間以内
- トランザクション完全性の保証

### 2.3 技術的制約

#### 2.3.1 システム制約
- HTTP メソッド: POST のみ
- データ形式: JSON
- 文字エンコーディング: UTF-8
- トランザクション: ACID特性遵守

#### 2.3.2 セキュリティ制約
- JWT認証必須
- 入力値のサニタイゼーション
- SQLインジェクション対策
- データ暗号化（位置情報）

### 2.4 業務制約

#### 2.4.1 登録制限
- 1ユーザー最大20提出先
- 同一ユーザー内での会社名重複禁止
- 有効な位置情報の必須入力
- 時間論理の整合性確保

#### 2.4.2 データ品質
- 必須項目の完全性確保
- データ形式の標準化
- 業務ルール適用の徹底
- 監査ログの記録

## 3. 業務フロー・ユースケース

### 3.1 基本フロー

#### 3.1.1 新規登録フロー
```
1. ユーザーが提出先登録を要求
2. システムが認証・認可を確認
3. 入力データのバリデーション
4. 重複チェックの実行
5. データベースへの登録処理
6. 登録成功レスポンスの返却
```

#### 3.1.2 データ検証フロー
```
1. 必須項目の存在確認
2. データ形式・範囲の検証
3. 業務ルールの適用
4. 重複データの検出
5. 整合性チェックの実行
```

### 3.2 代替フロー

#### 3.2.1 重複データ検出フロー
```
1. 会社名の重複検出
2. 重複エラーメッセージの生成
3. 登録失敗レスポンス返却
4. 代替案の提示（会社名変更など）
```

#### 3.2.2 部分的エラー処理フロー
```
1. 一部項目のバリデーションエラー検出
2. エラー詳細情報の収集
3. 修正が必要な項目の明示
4. 部分修正での再試行案内
```

### 3.3 例外フロー

#### 3.3.1 バリデーションエラーフロー
```
1. 入力データの形式エラー検出
2. 400 Bad Request エラー返却
3. 詳細エラー情報の提示
4. 修正方法の案内
```

#### 3.3.2 システムエラーフロー
```
1. データベース接続エラー等の検出
2. 500 Internal Server Error 返却
3. エラーログの記録
4. 管理者への通知
```

## 4. API仕様

### 4.1 エンドポイント
```
POST /api/v1/companies
```

### 4.2 リクエスト形式

```json
{
  "companyName": "株式会社サンプル",
  "location": {
    "latitude": "35.6762",
    "longitude": "139.6503"
  },
  "regulationStartTime": "09:00",
  "regulationEndTime": "18:00",
  "regulationRestStartTime": "12:00",
  "regulationRestEndTime": "13:00",
  "affiliationStartDate": "2025-01-01",
  "affiliationEndDate": null
}
```

### 4.3 リクエストパラメータ

| パラメータ名 | 型 | 必須 | 説明 |
|------------|---|-----|-----|
| companyName | String | ○ | 会社名（1文字以上100文字以内） |
| location | Object | ○ | 勤務地の位置情報 |
| location.latitude | String | ○ | 緯度（-90.0～90.0の範囲） |
| location.longitude | String | ○ | 経度（-180.0～180.0の範囲） |
| regulationStartTime | String | ○ | 規定勤務開始時刻（HH:mm形式） |
| regulationEndTime | String | ○ | 規定勤務終了時刻（HH:mm形式） |
| regulationRestStartTime | String | × | 規定休憩開始時刻（HH:mm形式） |
| regulationRestEndTime | String | × | 規定休憩終了時刻（HH:mm形式） |
| affiliationStartDate | String | ○ | 所属開始日（YYYY-MM-DD形式） |
| affiliationEndDate | String | × | 所属終了日（YYYY-MM-DD形式、null可） |

### 4.4 レスポンス形式

#### 4.4.1 成功レスポンス（201 Created）
```json
{
  "status": "success",
  "data": {
    "company": {
      "id": "12345678-1234-1234-1234-123456789abc",
      "companyName": "株式会社サンプル",
      "location": {
        "latitude": "35.6762",
        "longitude": "139.6503"
      },
      "regulationStartTime": "09:00",
      "regulationEndTime": "18:00",
      "regulationRestStartTime": "12:00",
      "regulationRestEndTime": "13:00",
      "affiliationStartDate": "2025-01-01",
      "affiliationEndDate": null,
      "createdAt": "2025-06-08T10:30:00+09:00",
      "updatedAt": "2025-06-08T10:30:00+09:00"
    }
  }
}
```

#### 4.4.2 エラーレスポンス（400 Bad Request）
```json
{
  "status": "error",
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "入力データに不正な値が含まれています",
    "details": [
      {
        "field": "companyName",
        "message": "会社名は1文字以上100文字以内で入力してください"
      },
      {
        "field": "location.latitude",
        "message": "緯度は-90.0から90.0の範囲で入力してください"
      }
    ]
  }
}
```

### 4.5 HTTPステータスコード

| ステータスコード | 説明 |
|---------------|-----|
| 201 Created | 勤怠情報提出先が正常に作成された |
| 400 Bad Request | リクエストパラメータに不正な値が含まれている |
| 401 Unauthorized | 認証が必要、または認証に失敗した |
| 403 Forbidden | リクエストしたリソースへのアクセス権限がない |
| 409 Conflict | 同じ会社名が既に存在している |
| 500 Internal Server Error | サーバー内部エラー |

| 500 Internal Server Error | サーバー内部エラー |

## 5. データ仕様

### 5.1 データモデル

#### 5.1.1 Company エンティティ（登録用）
```typescript
interface CompanyCreateInput {
  companyName: string;            // 会社名（1-200文字）
  location: {
    latitude: string;             // 緯度（小数点以下8桁まで）
    longitude: string;            // 経度（小数点以下8桁まで）
  };
  regulationStartTime: string;    // 規定開始時刻（HH:MM形式）
  regulationEndTime: string;      // 規定終了時刻（HH:MM形式）
  regulationRestStartTime?: string; // 規定休憩開始時刻（HH:MM形式、オプション）
  regulationRestEndTime?: string;   // 規定休憩終了時刻（HH:MM形式、オプション）
  affiliationStartDate: string;   // 所属開始日（YYYY-MM-DD形式）
  affiliationEndDate?: string;    // 所属終了日（YYYY-MM-DD形式、オプション）
}

interface CompanyEntity {
  id: string;                     // 提出先ID（UUID、自動生成）
  userId: string;                 // 所有者ユーザーID（JWT認証から取得）
  companyName: string;            // 会社名
  location: LocationData;         // 位置情報
  regulationStartTime: string;    // 規定開始時刻
  regulationEndTime: string;      // 規定終了時刻
  regulationRestStartTime?: string; // 規定休憩開始時刻
  regulationRestEndTime?: string;   // 規定休憩終了時刻
  affiliationStartDate: Date;     // 所属開始日
  affiliationEndDate?: Date;      // 所属終了日
  status: 'active';               // ステータス（登録時は常にactive）
  createdAt: Date;               // 作成日時（自動生成）
  updatedAt: Date;               // 更新日時（自動生成）
  deletedAt?: Date;              // 削除日時（論理削除用、初期値はnull）
}
```

### 5.2 バリデーション仕様

#### 5.2.1 基本項目バリデーション
```typescript
interface ValidationRules {
  companyName: {
    required: true,
    minLength: 1,
    maxLength: 200,
    pattern: /^[^\x00-\x1f\x7f-\x9f]*$/  // 制御文字を除外
  };
  location: {
    latitude: {
      required: true,
      type: 'decimal',
      min: -90.0,
      max: 90.0,
      precision: 8
    };
    longitude: {
      required: true,
      type: 'decimal',
      min: -180.0,
      max: 180.0,
      precision: 8
    };
  };
  timeFields: {
    pattern: /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/,  // HH:MM形式
    required: ['regulationStartTime', 'regulationEndTime']
  };
  dateFields: {
    pattern: /^\d{4}-\d{2}-\d{2}$/,  // YYYY-MM-DD形式
    required: ['affiliationStartDate']
  };
}
```

#### 5.2.2 業務ルールバリデーション
```typescript
class BusinessRuleValidator {
  static validateTimeConsistency(data: CompanyCreateInput): ValidationError[] {
    const errors: ValidationError[] = [];
    
    // 勤務時間の整合性チェック
    if (data.regulationStartTime >= data.regulationEndTime) {
      errors.push({
        field: 'regulationEndTime',
        message: '規定終了時刻は開始時刻より後に設定してください'
      });
    }
    
    // 休憩時間の整合性チェック
    if (data.regulationRestStartTime && data.regulationRestEndTime) {
      if (data.regulationRestStartTime >= data.regulationRestEndTime) {
        errors.push({
          field: 'regulationRestEndTime',
          message: '休憩終了時刻は開始時刻より後に設定してください'
        });
      }
      
      // 休憩時間が勤務時間内にあるかチェック
      if (data.regulationRestStartTime < data.regulationStartTime || 
          data.regulationRestEndTime > data.regulationEndTime) {
        errors.push({
          field: 'regulationRestStartTime',
          message: '休憩時間は勤務時間内に設定してください'
        });
      }
    }
    
    // 所属期間の整合性チェック
    if (data.affiliationEndDate) {
      if (new Date(data.affiliationStartDate) >= new Date(data.affiliationEndDate)) {
        errors.push({
          field: 'affiliationEndDate',
          message: '所属終了日は開始日より後に設定してください'
        });
      }
    }
    
    return errors;
  }
}
```

### 5.3 データ変換仕様

#### 5.3.1 入力データ正規化
```typescript
class DataNormalizer {
  static normalizeCompanyInput(input: CompanyCreateInput): NormalizedCompanyData {
    return {
      companyName: input.companyName.trim(),
      location: {
        latitude: parseFloat(input.location.latitude).toFixed(8),
        longitude: parseFloat(input.location.longitude).toFixed(8)
      },
      regulationStartTime: this.normalizeTime(input.regulationStartTime),
      regulationEndTime: this.normalizeTime(input.regulationEndTime),
      regulationRestStartTime: input.regulationRestStartTime 
        ? this.normalizeTime(input.regulationRestStartTime) : null,
      regulationRestEndTime: input.regulationRestEndTime 
        ? this.normalizeTime(input.regulationRestEndTime) : null,
      affiliationStartDate: new Date(input.affiliationStartDate),
      affiliationEndDate: input.affiliationEndDate 
        ? new Date(input.affiliationEndDate) : null
    };
  }
  
  private static normalizeTime(timeString: string): string {
    const [hours, minutes] = timeString.split(':');
    return `${hours.padStart(2, '0')}:${minutes.padStart(2, '0')}`;
  }
}
```

## 6. 業務ロジック

### 6.1 登録処理フロー

#### 6.1.1 メイン登録サービス
```typescript
class CompanyRegistrationService {
  async registerCompany(userId: string, input: CompanyCreateInput): Promise<CompanyRegistrationResult> {
    // 1. 入力値の基本バリデーション
    const validationErrors = this.validateInput(input);
    if (validationErrors.length > 0) {
      throw new ValidationError('入力データに不正な値が含まれています', validationErrors);
    }
    
    // 2. 業務ルールの検証
    const businessRuleErrors = BusinessRuleValidator.validateTimeConsistency(input);
    if (businessRuleErrors.length > 0) {
      throw new ValidationError('業務ルールに違反しています', businessRuleErrors);
    }
    
    // 3. ユーザー制限チェック
    await this.checkUserLimitations(userId);
    
    // 4. 重複チェック
    await this.checkDuplicateCompany(userId, input.companyName);
    
    // 5. データ正規化
    const normalizedData = DataNormalizer.normalizeCompanyInput(input);
    
    // 6. エンティティ作成
    const companyEntity = this.createCompanyEntity(userId, normalizedData);
    
    // 7. データベース保存
    const savedCompany = await this.companyRepository.save(companyEntity);
    
    // 8. レスポンス構築
    return this.buildRegistrationResponse(savedCompany);
  }
}
```

#### 6.1.2 制限チェック処理
```typescript
class UserLimitationChecker {
  static async checkCompanyLimit(userId: string): Promise<void> {
    const companyCount = await CompanyRepository.countByUserId(userId);
    const maxCompanies = 20; // 設定値
    
    if (companyCount >= maxCompanies) {
      throw new BusinessRuleError(
        `提出先の登録は${maxCompanies}件までです。現在${companyCount}件登録済みです。`
      );
    }
  }
}
```

#### 6.1.3 重複チェック処理
```typescript
class DuplicateChecker {
  static async checkCompanyNameDuplicate(userId: string, companyName: string): Promise<void> {
    const existingCompany = await CompanyRepository.findByUserIdAndName(userId, companyName);
    
    if (existingCompany && !existingCompany.deletedAt) {
      throw new ConflictError(
        '同じ会社名が既に登録されています。別の名前を入力してください。',
        { existingCompanyId: existingCompany.id }
      );
    }
  }
}
```

### 6.2 エンティティ生成ロジック

#### 6.2.1 Company エンティティファクトリ
```typescript
class CompanyEntityFactory {
  static create(userId: string, data: NormalizedCompanyData): CompanyEntity {
    const now = new Date();
    
    return {
      id: uuidv4(),
      userId,
      companyName: data.companyName,
      location: data.location,
      regulationStartTime: data.regulationStartTime,
      regulationEndTime: data.regulationEndTime,
      regulationRestStartTime: data.regulationRestStartTime,
      regulationRestEndTime: data.regulationRestEndTime,
      affiliationStartDate: data.affiliationStartDate,
      affiliationEndDate: data.affiliationEndDate,
      status: 'active',
      createdAt: now,
      updatedAt: now,
      deletedAt: null
    };
  }
}
```

### 6.3 トランザクション制御

#### 6.3.1 データベーストランザクション
```typescript
class TransactionManager {
  async executeRegistration(
    operation: () => Promise<CompanyEntity>
  ): Promise<CompanyEntity> {
    const transaction = await this.database.beginTransaction();
    
    try {
      const result = await operation();
      await transaction.commit();
      return result;
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }
}
```

## 7. セキュリティ・権限制御

### 7.1 認証・認可

#### 7.1.1 JWT認証ミドルウェア
```typescript
class AuthenticationMiddleware {
  async authenticate(req: Request, res: Response, next: NextFunction) {
    try {
      const token = this.extractToken(req);
      const payload = await this.verifyToken(token);
      
      req.user = {
        userId: payload.userId,
        role: payload.role,
        permissions: payload.permissions
      };
      
      next();
    } catch (error) {
      res.status(401).json({
        status: 'error',
        error: {
          code: 'AUTHENTICATION_REQUIRED',
          message: '認証が必要です'
        }
      });
    }
  }
}
```

#### 7.1.2 認可チェック
```typescript
class AuthorizationChecker {
  static checkCompanyRegistrationPermission(user: AuthenticatedUser): void {
    if (!user.permissions.includes('company:create')) {
      throw new ForbiddenError('提出先登録の権限がありません');
    }
  }
}
```

### 7.2 入力値セキュリティ

#### 7.2.1 入力サニタイゼーション
```typescript
class InputSanitizer {
  static sanitizeCompanyInput(input: any): CompanyCreateInput {
    return {
      companyName: this.sanitizeString(input.companyName),
      location: {
        latitude: this.sanitizeNumber(input.location?.latitude),
        longitude: this.sanitizeNumber(input.location?.longitude)
      },
      regulationStartTime: this.sanitizeTime(input.regulationStartTime),
      regulationEndTime: this.sanitizeTime(input.regulationEndTime),
      regulationRestStartTime: input.regulationRestStartTime 
        ? this.sanitizeTime(input.regulationRestStartTime) : undefined,
      regulationRestEndTime: input.regulationRestEndTime 
        ? this.sanitizeTime(input.regulationRestEndTime) : undefined,
      affiliationStartDate: this.sanitizeDate(input.affiliationStartDate),
      affiliationEndDate: input.affiliationEndDate 
        ? this.sanitizeDate(input.affiliationEndDate) : undefined
    };
  }
  
  private static sanitizeString(value: any): string {
    if (typeof value !== 'string') return '';
    return value.replace(/[<>\"'&]/g, '').trim();
  }
}
```

### 7.3 データ保護

#### 7.3.1 位置情報の暗号化
```typescript
class LocationEncryption {
  static encryptLocation(location: LocationData): EncryptedLocationData {
    return {
      latitude: CryptoUtil.encrypt(location.latitude),
      longitude: CryptoUtil.encrypt(location.longitude)
    };
  }
  
  static decryptLocation(encryptedLocation: EncryptedLocationData): LocationData {
    return {
      latitude: CryptoUtil.decrypt(encryptedLocation.latitude),
      longitude: CryptoUtil.decrypt(encryptedLocation.longitude)
    };
  }
}
```

### 7.4 セキュリティログ

#### 7.4.1 登録操作ログ
```typescript
class SecurityLogger {
  static logCompanyRegistration(event: CompanyRegistrationEvent) {
    logger.info('COMPANY_REGISTRATION', {
      userId: event.userId,
      companyId: event.companyId,
      companyName: event.companyName,
      timestamp: new Date().toISOString(),
      ipAddress: event.ipAddress,
      userAgent: event.userAgent,
      success: event.success,
      errorCode: event.errorCode
    });
  }
}
```

## 8. エラーハンドリング・例外処理

### 8.1 エラー分類体系

#### 8.1.1 クライアントエラー（4xx）
```typescript
class ClientError extends Error {
  constructor(
    public code: string,
    public message: string,
    public statusCode: number,
    public details?: any[]
  ) {
    super(message);
  }
}

class ValidationError extends ClientError {
  constructor(message: string, details?: ValidationErrorDetail[]) {
    super('VALIDATION_ERROR', message, 400, details);
  }
}

class ConflictError extends ClientError {
  constructor(message: string, details?: any) {
    super('CONFLICT', message, 409, details);
  }
}

class BusinessRuleError extends ClientError {
  constructor(message: string) {
    super('BUSINESS_RULE_VIOLATION', message, 400);
  }
}
```

#### 8.1.2 サーバーエラー（5xx）
```typescript
class ServerError extends Error {
  constructor(
    public code: string,
    public message: string,
    public statusCode: number = 500,
    public originalError?: Error
  ) {
    super(message);
  }
}

class DatabaseError extends ServerError {
  constructor(message: string, originalError?: Error) {
    super('DATABASE_ERROR', message, 500, originalError);
  }
}
```

### 8.2 バリデーションエラー処理

#### 8.2.1 包括的バリデーション
```typescript
class ComprehensiveValidator {
  static validateCompanyRegistration(input: CompanyCreateInput): ValidationResult {
    const errors: ValidationErrorDetail[] = [];
    
    // 基本項目検証
    errors.push(...this.validateBasicFields(input));
    
    // 業務ルール検証
    errors.push(...this.validateBusinessRules(input));
    
    // セキュリティ検証
    errors.push(...this.validateSecurityRules(input));
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  
  private static validateBasicFields(input: CompanyCreateInput): ValidationErrorDetail[] {
    const errors: ValidationErrorDetail[] = [];
    
    // 会社名検証
    if (!input.companyName || input.companyName.trim().length === 0) {
      errors.push({
        field: 'companyName',
        message: '会社名は必須です',
        code: 'REQUIRED_FIELD'
      });
    } else if (input.companyName.length > 200) {
      errors.push({
        field: 'companyName',
        message: '会社名は200文字以内で入力してください',
        code: 'MAX_LENGTH_EXCEEDED'
      });
    }
    
    // 位置情報検証
    if (!input.location || !input.location.latitude || !input.location.longitude) {
      errors.push({
        field: 'location',
        message: '位置情報は必須です',
        code: 'REQUIRED_FIELD'
      });
    } else {
      const lat = parseFloat(input.location.latitude);
      const lon = parseFloat(input.location.longitude);
      
      if (isNaN(lat) || lat < -90 || lat > 90) {
        errors.push({
          field: 'location.latitude',
          message: '緯度は-90.0から90.0の範囲で入力してください',
          code: 'INVALID_RANGE'
        });
      }
      
      if (isNaN(lon) || lon < -180 || lon > 180) {
        errors.push({
          field: 'location.longitude',
          message: '経度は-180.0から180.0の範囲で入力してください',
          code: 'INVALID_RANGE'
        });
      }
    }
    
    return errors;
  }
}
```

### 8.3 例外処理パターン

#### 8.3.1 グローバルエラーハンドラ
```typescript
class GlobalErrorHandler {
  static handle(error: Error, req: Request, res: Response, next: NextFunction) {
    // エラーログ記録
    ErrorLogger.logError(error, {
      userId: req.user?.userId,
      path: req.path,
      method: req.method,
      body: req.body,
      timestamp: new Date().toISOString()
    });
    
    // エラータイプ別処理
    if (error instanceof ValidationError) {
      return res.status(400).json({
        status: 'error',
        error: {
          code: error.code,
          message: error.message,
          details: error.details
        }
      });
    }
    
    if (error instanceof ConflictError) {
      return res.status(409).json({
        status: 'error',
        error: {
          code: error.code,
          message: error.message
        }
      });
    }
    
    if (error instanceof DatabaseError) {
      return res.status(500).json({
        status: 'error',
        error: {
          code: 'INTERNAL_SERVER_ERROR',
          message: '一時的なエラーが発生しました。しばらく後に再試行してください。'
        }
      });
    }
    
    // 未知のエラー
    return res.status(500).json({
      status: 'error',
      error: {
        code: 'UNKNOWN_ERROR',
        message: 'システムエラーが発生しました'
      }
    });
  }
}
```

## 9. 非機能要件

### 9.1 性能要件

#### 9.1.1 レスポンス時間
- **通常登録処理**: 500ms以内（90パーセンタイル）
- **複雑検証処理**: 1秒以内（90パーセンタイル）
- **エラー応答**: 100ms以内

#### 9.1.2 スループット
- **同時登録処理**: 50リクエスト/秒
- **ピーク時負荷**: 通常時の120%まで対応
- **バッチ処理**: 100件/分

#### 9.1.3 リソース使用量
- **CPU使用率**: 平均40%以下、最大60%以下
- **メモリ使用量**: 平均50%以下、最大70%以下
- **DB接続プール**: 最大30接続

### 9.2 可用性要件

#### 9.2.1 稼働率
- **目標稼働率**: 99.9%
- **計画停止**: 月1時間以内
- **障害復旧時間**: 平均2時間以内

#### 9.2.2 信頼性
- **データ完全性**: 100%保証
- **トランザクション整合性**: ACID特性遵守
- **重複登録防止**: 確実な一意性制約

### 9.3 保守性要件

#### 9.3.1 監視・運用
- **ヘルスチェック**: /health エンドポイント
- **メトリクス**: 登録成功率、エラー率、応答時間
- **アラート**: 異常検知時の自動通知

#### 9.3.2 ログ・監査
- **アプリケーションログ**: 構造化ログ形式
- **セキュリティログ**: 全操作の記録
- **パフォーマンスログ**: 応答時間・リソース使用量

### 9.4 拡張性要件

#### 9.4.1 スケーラビリティ
- **水平スケーリング**: ロードバランサー対応
- **データベース**: 読み書き分離対応
- **キャッシュ**: 分散キャッシュ対応

#### 9.4.2 将来拡張
- **API バージョニング**: 後方互換性確保
- **プラグイン機構**: 追加検証ルール
- **多言語対応**: メッセージ国際化

## 10. テスト仕様

### 10.1 テスト方針

#### 10.1.1 テスト戦略
- **テスト駆動開発**: 機能実装前のテストケース作成
- **自動化**: CI/CDパイプラインでの自動テスト実行
- **品質ゲート**: 全テスト成功を本番デプロイ条件とする

#### 10.1.2 品質基準
- **コードカバレッジ**: 85%以上
- **テスト成功率**: 100%
- **性能基準**: 全テストケースで性能要件を満たすこと

### 10.2 単体テスト仕様

#### 10.2.1 バリデーション機能テスト
```typescript
describe('CompanyValidation', () => {
  describe('基本項目検証', () => {
    it('正常な入力で検証が通る', () => {
      // Given
      const validInput = {
        companyName: '株式会社テスト',
        location: { latitude: '35.6762', longitude: '139.6503' },
        regulationStartTime: '09:00',
        regulationEndTime: '18:00',
        affiliationStartDate: '2025-01-01'
      };
      
      // When
      const result = validator.validate(validInput);
      
      // Then
      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });
    
    it('会社名が空の場合エラーが発生する', () => {
      // Given
      const invalidInput = { companyName: '' };
      
      // When
      const result = validator.validate(invalidInput);
      
      // Then
      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual({
        field: 'companyName',
        message: '会社名は必須です',
        code: 'REQUIRED_FIELD'
      });
    });
  });
  
  describe('業務ルール検証', () => {
    it('開始時刻が終了時刻より遅い場合エラーが発生する', () => {
      // Given
      const invalidInput = {
        regulationStartTime: '18:00',
        regulationEndTime: '09:00'
      };
      
      // When
      const result = BusinessRuleValidator.validateTimeConsistency(invalidInput);
      
      // Then
      expect(result).toContainEqual({
        field: 'regulationEndTime',
        message: '規定終了時刻は開始時刻より後に設定してください'
      });
    });
  });
});
```

#### 10.2.2 登録処理テスト
```typescript
describe('CompanyRegistrationService', () => {
  describe('registerCompany', () => {
    it('正常なデータで登録が成功する', async () => {
      // Given
      const userId = 'user-123';
      const validInput = createValidCompanyInput();
      
      // When
      const result = await service.registerCompany(userId, validInput);
      
      // Then
      expect(result.status).toBe('success');
      expect(result.data.company.id).toBeDefined();
      expect(result.data.company.companyName).toBe(validInput.companyName);
    });
    
    it('重複する会社名で登録が失敗する', async () => {
      // Given
      const userId = 'user-123';
      const duplicateInput = { companyName: '既存会社' };
      mockRepository.findByUserIdAndName.mockResolvedValue(existingCompany);
      
      // When & Then
      await expect(service.registerCompany(userId, duplicateInput))
        .rejects.toThrow(ConflictError);
    });
  });
});
```

### 10.3 統合テスト仕様

#### 10.3.1 API統合テスト
```typescript
describe('POST /api/v1/companies', () => {
  it('認証済みユーザーが提出先を登録できる', async () => {
    // Given
    const token = await generateValidToken('user-123');
    const companyData = createValidCompanyData();
    
    // When
    const response = await request(app)
      .post('/api/v1/companies')
      .set('Authorization', `Bearer ${token}`)
      .send(companyData);
    
    // Then
    expect(response.status).toBe(201);
    expect(response.body.status).toBe('success');
    expect(response.body.data.company.id).toBeDefined();
  });
  
  it('バリデーションエラーで400が返される', async () => {
    // Given
    const token = await generateValidToken('user-123');
    const invalidData = { companyName: '' };
    
    // When
    const response = await request(app)
      .post('/api/v1/companies')
      .set('Authorization', `Bearer ${token}`)
      .send(invalidData);
    
    // Then
    expect(response.status).toBe(400);
    expect(response.body.error.code).toBe('VALIDATION_ERROR');
    expect(response.body.error.details).toBeDefined();
  });
});
```

### 10.4 性能テスト仕様

#### 10.4.1 負荷テスト
```typescript
describe('Performance Tests', () => {
  it('50同時ユーザーでの登録性能', async () => {
    // Given
    const concurrentUsers = 50;
    const promises = [];
    
    // When
    for (let i = 0; i < concurrentUsers; i++) {
      promises.push(performRegistrationRequest(i));
    }
    
    const startTime = Date.now();
    const results = await Promise.all(promises);
    const endTime = Date.now();
    
    // Then
    const averageResponseTime = (endTime - startTime) / concurrentUsers;
    expect(averageResponseTime).toBeLessThan(500); // 500ms以内
    expect(results.every(r => r.status === 201)).toBe(true);
  });
});
```

### 10.5 テストデータ管理

#### 10.5.1 テストデータファクトリ
```typescript
class TestDataFactory {
  static createValidCompanyInput(overrides?: Partial<CompanyCreateInput>): CompanyCreateInput {
    return {
      companyName: 'テスト株式会社',
      location: {
        latitude: '35.6762',
        longitude: '139.6503'
      },
      regulationStartTime: '09:00',
      regulationEndTime: '18:00',
      regulationRestStartTime: '12:00',
      regulationRestEndTime: '13:00',
      affiliationStartDate: '2025-01-01',
      affiliationEndDate: null,
      ...overrides
    };
  }
}
```

## 11. 実装ノート・技術的詳細

### 11.1 技術スタック

#### 11.1.1 バックエンド技術
- **ランタイム**: Node.js 18 LTS
- **フレームワーク**: Express.js 4.x
- **言語**: TypeScript 5.x
- **データベース**: PostgreSQL 14
- **ORM**: Prisma 5.x
- **認証**: JWT + bcrypt
- **バリデーション**: Joi 17.x

#### 11.1.2 開発・運用ツール
- **テスト**: Jest + Supertest
- **コード品質**: ESLint + Prettier
- **CI/CD**: GitHub Actions
- **コンテナ**: Docker + Docker Compose
- **監視**: Prometheus + Grafana
- **ログ**: Winston + Elasticsearch

### 11.2 アーキテクチャ実装

#### 11.2.1 レイヤード設計
```
┌─────────────────────┐
│   Controller Layer  │ ← HTTP リクエスト/レスポンス
├─────────────────────┤
│   Service Layer     │ ← 業務ロジック・トランザクション
├─────────────────────┤
│   Repository Layer  │ ← データアクセス・永続化
├─────────────────────┤
│   Entity Layer      │ ← ドメインモデル・ビジネスルール
└─────────────────────┘
```

#### 11.2.2 依存性注入コンテナ
```typescript
class DIContainer {
  private static instance: DIContainer;
  private dependencies = new Map();
  
  static getInstance(): DIContainer {
    if (!this.instance) {
      this.instance = new DIContainer();
    }
    return this.instance;
  }
  
  register<T>(token: string, factory: () => T): void {
    this.dependencies.set(token, factory);
  }
  
  resolve<T>(token: string): T {
    const factory = this.dependencies.get(token);
    if (!factory) {
      throw new Error(`Dependency ${token} not found`);
    }
    return factory();
  }
}

// 依存関係の登録
DIContainer.getInstance().register('CompanyRepository', () => new CompanyRepository());
DIContainer.getInstance().register('CompanyService', () => 
  new CompanyService(DIContainer.getInstance().resolve('CompanyRepository'))
);
```

### 11.3 データベース実装

#### 11.3.1 Prismaスキーマ定義
```prisma
model Company {
  id                       String    @id @default(uuid())
  userId                   String    @map("user_id")
  companyName              String    @map("company_name") @db.VarChar(200)
  locationLatitude         String    @map("location_latitude") @db.Decimal(11, 8)
  locationLongitude        String    @map("location_longitude") @db.Decimal(11, 8)
  regulationStartTime      String    @map("regulation_start_time") @db.Char(5)
  regulationEndTime        String    @map("regulation_end_time") @db.Char(5)
  regulationRestStartTime  String?   @map("regulation_rest_start_time") @db.Char(5)
  regulationRestEndTime    String?   @map("regulation_rest_end_time") @db.Char(5)
  affiliationStartDate     DateTime  @map("affiliation_start_date") @db.Date
  affiliationEndDate       DateTime? @map("affiliation_end_date") @db.Date
  status                   String    @default("active") @db.VarChar(20)
  createdAt                DateTime  @default(now()) @map("created_at")
  updatedAt                DateTime  @updatedAt @map("updated_at")
  deletedAt                DateTime? @map("deleted_at")
  
  // インデックス
  @@index([userId])
  @@index([userId, companyName])
  @@index([status])
  @@unique([userId, companyName], name: "unique_user_company")
  @@map("companies")
}
```

#### 11.3.2 リポジトリ実装
```typescript
class CompanyRepository {
  constructor(private prisma: PrismaClient) {}
  
  async save(company: CompanyEntity): Promise<CompanyEntity> {
    try {
      const savedCompany = await this.prisma.company.create({
        data: {
          id: company.id,
          userId: company.userId,
          companyName: company.companyName,
          locationLatitude: company.location.latitude,
          locationLongitude: company.location.longitude,
          regulationStartTime: company.regulationStartTime,
          regulationEndTime: company.regulationEndTime,
          regulationRestStartTime: company.regulationRestStartTime,
          regulationRestEndTime: company.regulationRestEndTime,
          affiliationStartDate: company.affiliationStartDate,
          affiliationEndDate: company.affiliationEndDate,
          status: company.status
        }
      });
      
      return this.mapToEntity(savedCompany);
    } catch (error) {
      if (error.code === 'P2002') { // Unique constraint violation
        throw new ConflictError('同じ会社名が既に登録されています');
      }
      throw new DatabaseError('データベースエラーが発生しました', error);
    }
  }
  
  async findByUserIdAndName(userId: string, companyName: string): Promise<CompanyEntity | null> {
    const company = await this.prisma.company.findFirst({
      where: {
        userId,
        companyName,
        deletedAt: null
      }
    });
    
    return company ? this.mapToEntity(company) : null;
  }
  
  async countByUserId(userId: string): Promise<number> {
    return await this.prisma.company.count({
      where: {
        userId,
        deletedAt: null
      }
    });
  }
  
  private mapToEntity(data: any): CompanyEntity {
    return {
      id: data.id,
      userId: data.userId,
      companyName: data.companyName,
      location: {
        latitude: data.locationLatitude,
        longitude: data.locationLongitude
      },
      regulationStartTime: data.regulationStartTime,
      regulationEndTime: data.regulationEndTime,
      regulationRestStartTime: data.regulationRestStartTime,
      regulationRestEndTime: data.regulationRestEndTime,
      affiliationStartDate: data.affiliationStartDate,
      affiliationEndDate: data.affiliationEndDate,
      status: data.status,
      createdAt: data.createdAt,
      updatedAt: data.updatedAt,
      deletedAt: data.deletedAt
    };
  }
}
```

### 11.4 セキュリティ実装

#### 11.4.1 JWTミドルウェア
```typescript
class JWTMiddleware {
  constructor(private secret: string) {}
  
  async authenticate(req: Request, res: Response, next: NextFunction) {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader?.startsWith('Bearer ')) {
        throw new AuthenticationError('Authorization header missing');
      }
      
      const token = authHeader.slice(7);
      const payload = jwt.verify(token, this.secret) as JWTPayload;
      
      req.user = {
        userId: payload.userId,
        role: payload.role,
        permissions: payload.permissions
      };
      
      next();
    } catch (error) {
      res.status(401).json({
        status: 'error',
        error: {
          code: 'AUTHENTICATION_REQUIRED',
          message: '認証が必要です'
        }
      });
    }
  }
}
```

#### 11.4.2 レート制限実装
```typescript
class RateLimiter {
  private limits = new Map<string, number[]>();
  
  checkLimit(userId: string, endpoint: string, limit: number = 3): boolean {
    const key = `${userId}:${endpoint}`;
    const now = Date.now();
    const windowStart = now - 60000; // 1分間のウィンドウ
    
    if (!this.limits.has(key)) {
      this.limits.set(key, []);
    }
    
    const requests = this.limits.get(key)!;
    const recentRequests = requests.filter(time => time > windowStart);
    
    if (recentRequests.length >= limit) {
      return false;
    }
    
    recentRequests.push(now);
    this.limits.set(key, recentRequests);
    return true;
  }
}
```

### 11.5 監視・ログ実装

#### 11.5.1 構造化ログ
```typescript
class StructuredLogger {
  private logger: winston.Logger;
  
  constructor() {
    this.logger = winston.createLogger({
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
      ),
      transports: [
        new winston.transports.Console(),
        new winston.transports.File({ filename: 'app.log' })
      ]
    });
  }
  
  logCompanyRegistration(context: CompanyRegistrationContext) {
    this.logger.info('COMPANY_REGISTRATION', {
      userId: context.userId,
      companyId: context.companyId,
      companyName: context.companyName,
      success: context.success,
      duration: context.duration,
      timestamp: new Date().toISOString()
    });
  }
  
  logError(error: Error, context: ErrorContext) {
    this.logger.error('ERROR_OCCURRED', {
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      },
      context,
      timestamp: new Date().toISOString()
    });
  }
}
```

#### 11.5.2 メトリクス収集
```typescript
class MetricsCollector {
  private metrics = {
    registrationCount: 0,
    registrationErrors: 0,
    responseTimeSum: 0,
    responseTimeCount: 0
  };
  
  recordRegistration(success: boolean, responseTime: number) {
    this.metrics.registrationCount++;
    if (!success) this.metrics.registrationErrors++;
    this.metrics.responseTimeSum += responseTime;
    this.metrics.responseTimeCount++;
  }
  
  getMetrics() {
    return {
      ...this.metrics,
      averageResponseTime: this.metrics.responseTimeSum / this.metrics.responseTimeCount,
      errorRate: this.metrics.registrationErrors / this.metrics.registrationCount
    };
  }
}
```

### 11.6 デプロイメント

#### 11.6.1 Dockerfile
```dockerfile
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM node:18-alpine AS runtime

RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

WORKDIR /app
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/package.json ./package.json

USER nodejs
EXPOSE 3000

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

CMD ["npm", "start"]
```

#### 11.6.2 docker-compose.yml
```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/kairos
      - JWT_SECRET=${JWT_SECRET}
      - NODE_ENV=production
    depends_on:
      - postgres
      - redis
    
  postgres:
    image: postgres:14-alpine
    environment:
      - POSTGRES_DB=kairos
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    
  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

## 変更履歴

| 日付 | 変更者 | 変更内容 |
|-----|-------|---------|
| 2025/06/08 | カーン | 初版作成 |
| 2025/06/09 | カーン | Level B標準構造完全適用（1-11章構成への統一完了） |
