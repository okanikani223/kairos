# 勤怠情報提出先取得機能 機能設計

<!-- ドキュメント情報 -->
**作成日**: 2025/06/08  
**最終更新**: 2025/06/09  
**バージョン**: 1.1  
**担当者**: カーン  
**レビュー状況**: レビュー中  

## 関連文書
- [勤怠情報提出先登録機能_機能設計.md](./勤怠情報提出先登録機能_機能設計.md)
- [勤怠情報提出先更新機能_機能設計.md](./勤怠情報提出先更新機能_機能設計.md)
- [勤怠情報提出先削除機能_機能設計.md](./勤怠情報提出先削除機能_機能設計.md)
- [ドキュメント構造統一標準.md](./ドキュメント構造統一標準.md)

## 1. 機能概要

### 1.1 機能の目的・背景

勤怠情報提出先取得機能は、登録済みの勤怠情報提出先（会社・組織）の情報を効率的に取得するためのAPIです。複数の勤務先を持つユーザーの提出先管理、勤怠登録時の提出先選択、システム設定の確認などに使用されます。

**主要目的**：
- 提出先情報の効率的な参照機能
- 複数提出先の一覧管理
- 提出先詳細情報の提供
- 勤怠登録時の選択肢提供

### 1.2 機能スコープ

**対象範囲**：
- 提出先一覧の取得
- 特定提出先の詳細取得
- ページネーション対応
- ソート・フィルタリング機能

**除外範囲**：
- 提出先情報の変更機能
- 他ユーザーの提出先情報参照
- 削除済み提出先の参照（管理者権限除く）
- 提出先の統計・分析機能

### 1.3 前提条件・制約事項

**前提条件**：
- 適切な認証・認可が行われていること
- 取得対象の提出先情報が存在すること
- ユーザーが参照権限を有すること

**制約事項**：
- 本人の登録した提出先のみ参照可能
- 無効化された提出先は通常参照不可
- 大量データ取得時のページネーション必須
- 機密情報は適切にマスク処理

## 2. 要件・制約事項

### 2.1 機能要件

#### 2.1.1 取得パターン
- **一覧取得**: 全提出先の概要情報取得
- **詳細取得**: 特定提出先の詳細情報取得
- **条件取得**: ステータス・期間による絞り込み
- **ソート取得**: 指定条件による並び替え

#### 2.1.2 表示制御
- ページネーション機能
- 表示件数の調整機能
- ソート機能（名前、作成日時等）
- フィルタリング機能（ステータス）

#### 2.1.3 データ提供
- 基本情報（会社名、所在地等）
- 設定情報（勤務時間、休憩時間等）
- ステータス情報（有効/無効）
- メタ情報（作成日時、更新日時等）

### 2.2 非機能要件

#### 2.2.1 パフォーマンス要件
**応答時間**: 300ms以内（単純取得）
**同時処理**: 100リクエスト/秒まで対応

#### 2.2.2 セキュリティ要件
**参照**: セキュリティ要件記載標準 3節（共通基盤要件）
- JWT認証必須
- 役割ベースアクセス制御

#### 2.2.3 エラーハンドリング
- HTTP標準ステータスコード使用
- 構造化エラーレスポンス
- ユーザー向けエラーメッセージ

#### 2.2.4 ログ要件
- アクセスログ記録必須
- エラーログ詳細記録
- パフォーマンスログ出力

### 2.3 技術的制約

#### 2.3.1 システム制約
- HTTP メソッド: GET のみ
- データ形式: JSON
- 文字エンコーディング: UTF-8
- ページング: クエリパラメータ方式

#### 2.3.2 セキュリティ制約
- JWT認証必須
- 所有者ベースアクセス制御
- 機密情報のマスキング
- ログ記録の徹底

### 2.4 業務制約

#### 2.4.1 アクセス制限
- 本人登録データのみ参照可能
- 管理者は全ユーザーデータ参照可能
- 無効化データは特権ユーザーのみ
- API利用頻度の制限

#### 2.4.2 データ品質
- リアルタイム性の確保
- データ整合性の維持
- 適切な権限制御
- 監査ログの記録

## 3. 業務フロー・ユースケース

### 3.1 基本フロー

#### 3.1.1 一覧取得フロー
```
1. ユーザーが提出先一覧を要求
2. システムが認証・認可を確認
3. 所有者データのフィルタリング
4. ページネーション・ソートの適用
5. レスポンスデータの構築
6. 一覧データの返却
```

#### 3.1.2 詳細取得フロー
```
1. ユーザーが特定提出先の詳細を要求
2. システムが認証・認可を確認
3. 提出先の存在・権限確認
4. 詳細データの取得
5. 機密情報のマスキング処理
6. 詳細データの返却
```

### 3.2 代替フロー

#### 3.2.1 キャッシュ利用フロー
```
1. 同一データの再取得要求
2. キャッシュの有効性確認
3. キャッシュデータの返却
4. キャッシュミス時のDB取得
```

#### 3.2.2 大量データ処理フロー
```
1. 大量データの取得要求
2. ページネーション強制適用
3. 分割取得の実行
4. 段階的データ返却
```

### 3.3 例外フロー

#### 3.3.1 データ不存在フロー
```
1. 存在しない提出先IDの指定
2. 404 Not Found エラーの返却
3. 適切なエラーメッセージの提示
```

#### 3.3.2 権限不足フロー
```
1. アクセス権限の不足検出
2. 403 Forbidden エラーの返却
3. 権限申請方法の案内
```

## 4. API仕様

### 4.1 エンドポイント

#### 4.1.1 提出先一覧取得
```
GET /api/v1/companies
```

#### 4.1.2 提出先詳細取得
```
GET /api/v1/companies/{companyId}
```

### 4.2 リクエスト形式

#### 4.2.1 一覧取得リクエスト
```
GET /api/v1/companies?status=active&page=1&limit=10
```

#### 4.2.2 詳細取得リクエスト
```
GET /api/v1/companies/12345678-1234-1234-1234-123456789abc
```

### 4.3 クエリパラメータ（一覧取得）

| パラメータ名 | 型 | 必須 | デフォルト値 | 説明 |
|------------|---|-----|------------|-----|
| status | String | × | active | 取得対象のステータス（active/inactive/all） |
| page | Number | × | 1 | ページ番号（1以上） |
| limit | Number | × | 10 | 1ページあたりの取得件数（1～100） |
| sortBy | String | × | companyName | ソート基準（companyName/createdAt/updatedAt） |
| order | String | × | asc | ソート順序（asc/desc） |

### 4.4 レスポンス形式

#### 4.4.1 一覧取得成功レスポンス（200 OK）
```json
{
  "status": "success",
  "data": {
    "companies": [
      {
        "id": "12345678-1234-1234-1234-123456789abc",
        "companyName": "株式会社サンプル",
        "location": {
          "latitude": "35.6762",
          "longitude": "139.6503"
        },
        "regulationStartTime": "09:00",
        "regulationEndTime": "18:00",
        "regulationRestStartTime": "12:00",
        "regulationRestEndTime": "13:00",
        "affiliationStartDate": "2025-01-01",
        "affiliationEndDate": null,
        "createdAt": "2025-06-08T10:30:00+09:00",
        "updatedAt": "2025-06-08T10:30:00+09:00"
      }
    ],
    "pagination": {
      "currentPage": 1,
      "totalPages": 3,
      "totalCount": 25,
      "hasNext": true,
      "hasPrev": false
    }
  }
}
```

#### 4.4.2 詳細取得成功レスポンス（200 OK）
```json
{
  "status": "success",
  "data": {
    "company": {
      "id": "12345678-1234-1234-1234-123456789abc",
      "companyName": "株式会社サンプル",
      "location": {
        "latitude": "35.6762",
        "longitude": "139.6503"
      },
      "regulationStartTime": "09:00",
      "regulationEndTime": "18:00",
      "regulationRestStartTime": "12:00",
      "regulationRestEndTime": "13:00",
      "affiliationStartDate": "2025-01-01",
      "affiliationEndDate": null,
      "createdAt": "2025-06-08T10:30:00+09:00",
      "updatedAt": "2025-06-08T10:30:00+09:00"
    }
  }
}
```

#### 4.4.3 データ未存在レスポンス（404 Not Found）
```json
{
  "status": "error",
  "error": {
    "code": "COMPANY_NOT_FOUND",
    "message": "指定された勤怠情報提出先が見つかりません"
  }
}
```

#### 4.4.4 エラーレスポンス（400 Bad Request）
```json
{
  "status": "error",
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "クエリパラメータに不正な値が含まれています",
    "details": [
      {
        "field": "limit",
        "message": "limitは1から100の間で指定してください"
      }
    ]
  }
}
```

### 4.5 HTTPステータスコード

| ステータスコード | 説明 |
|---------------|-----|
| 200 OK | データの取得が正常に完了した |
| 400 Bad Request | クエリパラメータに不正な値が含まれている |
| 401 Unauthorized | 認証が必要、または認証に失敗した |
| 403 Forbidden | リクエストしたリソースへのアクセス権限がない |
| 404 Not Found | 指定されたリソースが見つからない |
| 500 Internal Server Error | サーバー内部エラー |

## 5. データ仕様

### 5.1 データモデル

#### 5.1.1 Company エンティティ
```typescript
interface Company {
  id: string;                     // 提出先ID（UUID）
  userId: string;                 // 所有者ユーザーID（UUID）
  companyName: string;            // 会社名（最大200文字）
  location: {
    latitude: string;             // 緯度（小数点以下8桁まで）
    longitude: string;            // 経度（小数点以下8桁まで）
  };
  regulationStartTime: string;    // 規定開始時刻（HH:MM形式）
  regulationEndTime: string;      // 規定終了時刻（HH:MM形式）
  regulationRestStartTime: string; // 規定休憩開始時刻（HH:MM形式）
  regulationRestEndTime: string;   // 規定休憩終了時刻（HH:MM形式）
  affiliationStartDate: string;   // 所属開始日（YYYY-MM-DD形式）
  affiliationEndDate?: string;    // 所属終了日（YYYY-MM-DD形式、オプション）
  status: 'active' | 'inactive';  // ステータス
  createdAt: Date;               // 作成日時
  updatedAt: Date;               // 更新日時
  deletedAt?: Date;              // 削除日時（論理削除）
}
```

### 5.2 バリデーション仕様

#### 5.2.1 必須項目チェック
- id: 必須、UUID形式
- userId: 必須、UUID形式  
- companyName: 必須、1-200文字
- location: 必須、有効な緯度経度
- 各時刻項目: 必須、HH:MM形式

#### 5.2.2 データ形式チェック
- 時刻形式: 00:00-23:59の範囲
- 日付形式: YYYY-MM-DD形式、有効な日付
- 座標形式: 緯度(-90.0～90.0)、経度(-180.0～180.0)

#### 5.2.3 業務ルールチェック
- 開始時刻 < 終了時刻
- 休憩開始時刻 < 休憩終了時刻
- 所属開始日 ≤ 所属終了日（設定時）

### 5.3 データ変換仕様

#### 5.3.1 レスポンス用データ変換
```typescript
const convertToResponseFormat = (company: Company): CompanyResponse => {
  return {
    id: company.id,
    companyName: company.companyName,
    location: {
      latitude: company.location.latitude,
      longitude: company.location.longitude
    },
    regulationStartTime: company.regulationStartTime,
    regulationEndTime: company.regulationEndTime,
    regulationRestStartTime: company.regulationRestStartTime,
    regulationRestEndTime: company.regulationRestEndTime,
    affiliationStartDate: company.affiliationStartDate,
    affiliationEndDate: company.affiliationEndDate,
    createdAt: company.createdAt.toISOString(),
    updatedAt: company.updatedAt.toISOString()
  };
};
```

## 6. 業務ロジック

### 6.1 一覧取得ロジック

#### 6.1.1 基本取得処理
```typescript
class CompanyListService {
  async getCompaniesList(userId: string, params: ListParams): Promise<CompanyListResponse> {
    // 1. パラメータ検証
    this.validateListParams(params);
    
    // 2. 取得条件の構築
    const queryConditions = this.buildQueryConditions(userId, params);
    
    // 3. データ取得
    const companies = await this.companyRepository.findWithPagination(queryConditions);
    
    // 4. レスポンス構築
    return this.buildListResponse(companies, params);
  }
  
  private buildQueryConditions(userId: string, params: ListParams): QueryConditions {
    return {
      userId,
      status: params.status || 'active',
      orderBy: params.sortBy || 'companyName',
      order: params.order || 'asc',
      offset: (params.page - 1) * params.limit,
      limit: params.limit
    };
  }
}
```

#### 6.1.2 ソート・フィルタリング
```typescript
private buildSortConditions(sortBy: string, order: string): SortCondition {
  const allowedSortFields = ['companyName', 'createdAt', 'updatedAt'];
  const sortField = allowedSortFields.includes(sortBy) ? sortBy : 'companyName';
  const sortOrder = ['asc', 'desc'].includes(order) ? order : 'asc';
  
  return { field: sortField, order: sortOrder };
}
```

### 6.2 詳細取得ロジック

#### 6.2.1 基本取得処理
```typescript
class CompanyDetailService {
  async getCompanyDetail(userId: string, companyId: string): Promise<CompanyDetailResponse> {
    // 1. ID形式検証
    this.validateCompanyId(companyId);
    
    // 2. データ取得・権限チェック
    const company = await this.findCompanyWithPermissionCheck(userId, companyId);
    
    // 3. レスポンス構築
    return this.buildDetailResponse(company);
  }
  
  private async findCompanyWithPermissionCheck(
    userId: string, 
    companyId: string
  ): Promise<Company> {
    const company = await this.companyRepository.findById(companyId);
    
    if (!company) {
      throw new NotFoundError('指定された勤怠情報提出先が見つかりません');
    }
    
    if (company.userId !== userId) {
      throw new ForbiddenError('この提出先情報にアクセスする権限がありません');
    }
    
    if (company.deletedAt) {
      throw new NotFoundError('指定された勤怠情報提出先が見つかりません');
    }
    
    return company;
  }
}
```

### 6.3 キャッシュ戦略

#### 6.3.1 キャッシュキー設計
```typescript
class CacheKeyBuilder {
  static buildListKey(userId: string, params: ListParams): string {
    const paramString = Object.entries(params)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([key, value]) => `${key}:${value}`)
      .join('|');
    return `companies:list:${userId}:${paramString}`;
  }
  
  static buildDetailKey(userId: string, companyId: string): string {
    return `companies:detail:${userId}:${companyId}`;
  }
}
```

## 7. セキュリティ・権限制御

### 7.1 認証・認可

#### 7.1.1 JWT認証
```typescript
class AuthenticationMiddleware {
  async authenticate(req: Request, res: Response, next: NextFunction) {
    try {
      const token = this.extractToken(req);
      const payload = this.verifyToken(token);
      req.user = { userId: payload.userId };
      next();
    } catch (error) {
      res.status(401).json({
        status: 'error',
        error: {
          code: 'AUTHENTICATION_REQUIRED',
          message: '認証が必要です'
        }
      });
    }
  }
}
```

#### 7.1.2 所有者ベースアクセス制御
```typescript
class OwnershipValidator {
  static async validateOwnership(userId: string, companyId: string): Promise<boolean> {
    const company = await CompanyRepository.findById(companyId);
    return company && company.userId === userId && !company.deletedAt;
  }
}
```

### 7.2 データ保護

#### 7.2.1 機密情報マスキング
```typescript
class DataMasker {
  static maskSensitiveData(company: Company, userRole: string): Company {
    if (userRole !== 'admin') {
      // 一般ユーザーは詳細位置情報を小数点以下4桁まで制限
      company.location.latitude = this.truncateCoordinate(company.location.latitude, 4);
      company.location.longitude = this.truncateCoordinate(company.location.longitude, 4);
    }
    return company;
  }
  
  private static truncateCoordinate(coordinate: string, precision: number): string {
    const num = parseFloat(coordinate);
    return num.toFixed(precision);
  }
}
```

### 7.3 セキュリティログ

#### 7.3.1 アクセスログ記録
```typescript
class SecurityLogger {
  static logDataAccess(event: DataAccessEvent) {
    logger.info('DATA_ACCESS', {
      userId: event.userId,
      action: event.action,
      resource: event.resource,
      resourceId: event.resourceId,
      timestamp: new Date().toISOString(),
      ipAddress: event.ipAddress,
      userAgent: event.userAgent
    });
  }
}
```

## 8. エラーハンドリング・例外処理

### 8.1 エラー分類

#### 8.1.1 クライアントエラー（4xx）
```typescript
class ClientError extends Error {
  constructor(
    public code: string,
    public message: string,
    public statusCode: number,
    public details?: any[]
  ) {
    super(message);
  }
}

class ValidationError extends ClientError {
  constructor(message: string, details?: any[]) {
    super('VALIDATION_ERROR', message, 400, details);
  }
}

class NotFoundError extends ClientError {
  constructor(message: string = '指定されたリソースが見つかりません') {
    super('NOT_FOUND', message, 404);
  }
}

class ForbiddenError extends ClientError {
  constructor(message: string = 'リソースへのアクセス権限がありません') {
    super('FORBIDDEN', message, 403);
  }
}
```

#### 8.1.2 サーバーエラー（5xx）
```typescript
class ServerError extends Error {
  constructor(
    public code: string,
    public message: string,
    public statusCode: number = 500,
    public originalError?: Error
  ) {
    super(message);
  }
}

class DatabaseError extends ServerError {
  constructor(message: string, originalError?: Error) {
    super('DATABASE_ERROR', message, 500, originalError);
  }
}
```

### 8.2 例外処理パターン

#### 8.2.1 バリデーションエラー処理
```typescript
class ValidationErrorHandler {
  static handle(errors: ValidationError[]): ErrorResponse {
    return {
      status: 'error',
      error: {
        code: 'VALIDATION_ERROR',
        message: 'リクエストに不正な値が含まれています',
        details: errors.map(error => ({
          field: error.field,
          message: error.message
        }))
      }
    };
  }
}
```

#### 8.2.2 データベースエラー処理
```typescript
class DatabaseErrorHandler {
  static handle(error: DatabaseError): ErrorResponse {
    // 本番環境では詳細な内部エラー情報は隠蔽
    const message = process.env.NODE_ENV === 'production' 
      ? 'サーバー内部エラーが発生しました' 
      : error.message;
    
    return {
      status: 'error',
      error: {
        code: 'INTERNAL_SERVER_ERROR',
        message
      }
    };
  }
}
```

### 8.3 エラーログ記録

#### 8.3.1 エラーログ仕様
```typescript
class ErrorLogger {
  static logError(error: Error, context: ErrorContext) {
    const logLevel = this.determineLogLevel(error);
    
    logger[logLevel]('ERROR_OCCURRED', {
      errorCode: error.code || 'UNKNOWN_ERROR',
      message: error.message,
      stack: error.stack,
      userId: context.userId,
      requestId: context.requestId,
      timestamp: new Date().toISOString(),
      additionalContext: context
    });
  }
  
  private static determineLogLevel(error: Error): string {
    if (error instanceof ClientError) return 'warn';
    if (error instanceof ServerError) return 'error';
    return 'error';
  }
}
```

## 9. テスト仕様

### 9.1 テスト方針

#### 10.1.1 テストレベル
- **単体テスト**: 各関数・メソッドの個別テスト
- **統合テスト**: API エンドポイントの統合テスト
- **E2Eテスト**: ユーザーシナリオベースのテスト
- **性能テスト**: 負荷・ストレステスト

#### 10.1.2 品質基準
- **コードカバレッジ**: 80%以上
- **テスト成功率**: 100%
- **性能基準**: 仕様記載の性能要件を満たすこと

### 10.2 単体テスト仕様

#### 10.2.1 一覧取得機能テスト
```typescript
describe('CompanyListService', () => {
  describe('getCompaniesList', () => {
    it('正常な条件で提出先一覧を取得できる', async () => {
      // Given
      const userId = 'user-123';
      const params = { page: 1, limit: 10, status: 'active' };
      
      // When
      const result = await service.getCompaniesList(userId, params);
      
      // Then
      expect(result.status).toBe('success');
      expect(result.data.companies).toHaveLength(10);
      expect(result.data.pagination).toBeDefined();
    });
    
    it('無効なページ番号でバリデーションエラーが発生する', async () => {
      // Given
      const userId = 'user-123';
      const params = { page: 0, limit: 10 };
      
      // When & Then
      await expect(service.getCompaniesList(userId, params))
        .rejects.toThrow(ValidationError);
    });
  });
});
```

#### 10.2.2 詳細取得機能テスト
```typescript
describe('CompanyDetailService', () => {
  describe('getCompanyDetail', () => {
    it('正常な条件で提出先詳細を取得できる', async () => {
      // Given
      const userId = 'user-123';
      const companyId = 'company-456';
      
      // When
      const result = await service.getCompanyDetail(userId, companyId);
      
      // Then
      expect(result.status).toBe('success');
      expect(result.data.company.id).toBe(companyId);
    });
    
    it('存在しない提出先IDで404エラーが発生する', async () => {
      // Given
      const userId = 'user-123';
      const companyId = 'nonexistent-id';
      
      // When & Then
      await expect(service.getCompanyDetail(userId, companyId))
        .rejects.toThrow(NotFoundError);
    });
  });
});
```

### 10.3 統合テスト仕様

#### 10.3.1 API統合テスト
```typescript
describe('GET /api/v1/companies', () => {
  it('認証済みユーザーが提出先一覧を取得できる', async () => {
    // Given
    const token = await generateValidToken('user-123');
    
    // When
    const response = await request(app)
      .get('/api/v1/companies')
      .set('Authorization', `Bearer ${token}`)
      .query({ page: 1, limit: 10 });
    
    // Then
    expect(response.status).toBe(200);
    expect(response.body.status).toBe('success');
    expect(response.body.data.companies).toBeDefined();
  });
  
  it('未認証ユーザーが401エラーを受ける', async () => {
    // When
    const response = await request(app)
      .get('/api/v1/companies');
    
    // Then
    expect(response.status).toBe(401);
    expect(response.body.error.code).toBe('AUTHENTICATION_REQUIRED');
  });
});
```

### 10.4 性能テスト仕様

#### 10.4.1 負荷テスト
```typescript
describe('Performance Tests', () => {
  it('100同時ユーザーでの一覧取得性能', async () => {
    // Given
    const concurrentUsers = 100;
    const promises = [];
    
    // When
    for (let i = 0; i < concurrentUsers; i++) {
      promises.push(performListRequest());
    }
    
    const startTime = Date.now();
    const results = await Promise.all(promises);
    const endTime = Date.now();
    
    // Then
    const averageResponseTime = (endTime - startTime) / concurrentUsers;
    expect(averageResponseTime).toBeLessThan(500); // 500ms以内
    expect(results.every(r => r.status === 200)).toBe(true);
  });
});
```

### 10.5 テストデータ管理

#### 10.5.1 テストデータセット
```typescript
const testDataSets = {
  validUser: {
    userId: 'test-user-001',
    username: 'testuser',
    email: 'test@example.com'
  },
  validCompany: {
    id: 'test-company-001',
    companyName: 'テスト株式会社',
    location: {
      latitude: '35.6762',
      longitude: '139.6503'
    },
    // ... その他の必須フィールド
  }
};
```

## 11. 実装ノート・技術的詳細

### 11.1 技術スタック

#### 11.1.1 フレームワーク・ライブラリ
- **バックエンド**: Node.js + Express.js
- **データベース**: PostgreSQL
- **ORM**: Prisma
- **認証**: JWT + bcrypt
- **キャッシュ**: Redis
- **バリデーション**: Joi
- **テスト**: Jest + Supertest

#### 11.1.2 開発ツール
- **TypeScript**: 型安全性の確保
- **ESLint + Prettier**: コード品質の統一
- **Husky**: Git hooks による品質チェック
- **Docker**: 開発環境の統一

### 11.2 アーキテクチャ詳細

#### 11.2.1 レイヤードアーキテクチャ
```
┌─────────────────────┐
│   Controller Layer  │ ← HTTP リクエスト/レスポンス処理
├─────────────────────┤
│   Service Layer     │ ← 業務ロジック実装
├─────────────────────┤
│   Repository Layer  │ ← データアクセス処理
├─────────────────────┤
│   Model Layer       │ ← データモデル定義
└─────────────────────┘
```

#### 11.2.2 依存性注入パターン
```typescript
class CompanyController {
  constructor(
    private companyService: CompanyService,
    private authService: AuthService,
    private logger: Logger
  ) {}
  
  async getCompanies(req: Request, res: Response) {
    try {
      const userId = req.user.userId;
      const params = this.parseQueryParams(req.query);
      const result = await this.companyService.getCompaniesList(userId, params);
      res.json(result);
    } catch (error) {
      this.handleError(error, res);
    }
  }
}
```

### 11.3 データベース設計

#### 11.3.1 インデックス戦略
```sql
-- 基本検索用インデックス
CREATE INDEX idx_companies_user_id ON companies(user_id);
CREATE INDEX idx_companies_status ON companies(status);
CREATE INDEX idx_companies_created_at ON companies(created_at);

-- 複合インデックス（よく使用される検索条件の組み合わせ）
CREATE INDEX idx_companies_user_status ON companies(user_id, status);
CREATE INDEX idx_companies_user_created ON companies(user_id, created_at DESC);
```

#### 11.3.2 パフォーマンス最適化
```typescript
class CompanyRepository {
  async findByUserIdWithPagination(params: QueryParams): Promise<CompanyPage> {
    // prepared statement を使用してSQL インジェクション対策
    const query = `
      SELECT id, company_name, location, regulation_start_time, 
             regulation_end_time, regulation_rest_start_time, 
             regulation_rest_end_time, affiliation_start_date, 
             affiliation_end_date, created_at, updated_at
      FROM companies 
      WHERE user_id = $1 AND status = $2 AND deleted_at IS NULL
      ORDER BY ${this.sanitizeOrderBy(params.orderBy)} ${params.order}
      LIMIT $3 OFFSET $4
    `;
    
    return await this.db.query(query, [
      params.userId,
      params.status,
      params.limit,
      params.offset
    ]);
  }
}
```

### 11.4 セキュリティ実装

#### 11.4.1 入力値サニタイゼーション
```typescript
class InputSanitizer {
  static sanitizeQueryParams(params: any): SafeQueryParams {
    return {
      page: Math.max(1, parseInt(params.page) || 1),
      limit: Math.min(100, Math.max(1, parseInt(params.limit) || 10)),
      status: ['active', 'inactive', 'all'].includes(params.status) 
        ? params.status : 'active',
      sortBy: ['companyName', 'createdAt', 'updatedAt'].includes(params.sortBy)
        ? params.sortBy : 'companyName',
      order: ['asc', 'desc'].includes(params.order) ? params.order : 'asc'
    };
  }
}
```

#### 11.4.2 レート制限実装
```typescript
class RateLimiter {
  private static limits = new Map();
  
  static checkLimit(userId: string, endpoint: string): boolean {
    const key = `${userId}:${endpoint}`;
    const now = Date.now();
    const windowStart = now - 60000; // 1分間のウィンドウ
    
    if (!this.limits.has(key)) {
      this.limits.set(key, []);
    }
    
    const requests = this.limits.get(key);
    const recentRequests = requests.filter(time => time > windowStart);
    
    if (recentRequests.length >= 60) { // 1分間に60リクエストまで
      return false;
    }
    
    recentRequests.push(now);
    this.limits.set(key, recentRequests);
    return true;
  }
}
```

### 11.5 監視・ログ

#### 11.5.1 アプリケーションメトリクス
```typescript
class MetricsCollector {
  private static metrics = {
    requestCount: 0,
    responseTimeSum: 0,
    errorCount: 0
  };
  
  static recordRequest(responseTime: number, isError: boolean = false) {
    this.metrics.requestCount++;
    this.metrics.responseTimeSum += responseTime;
    if (isError) this.metrics.errorCount++;
  }
  
  static getMetrics() {
    return {
      ...this.metrics,
      averageResponseTime: this.metrics.responseTimeSum / this.metrics.requestCount,
      errorRate: this.metrics.errorCount / this.metrics.requestCount
    };
  }
}
```

#### 11.5.2 構造化ログ
```typescript
class StructuredLogger {
  static logApiAccess(context: ApiAccessContext) {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      type: 'api_access',
      userId: context.userId,
      method: context.method,
      path: context.path,
      statusCode: context.statusCode,
      responseTime: context.responseTime,
      userAgent: context.userAgent,
      ipAddress: context.ipAddress
    }));
  }
}
```

### 11.6 デプロイメント・運用

#### 11.6.1 Docker設定
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build
EXPOSE 3000
USER node
CMD ["npm", "start"]
```

#### 11.6.2 ヘルスチェック
```typescript
class HealthCheck {
  static async checkHealth(): Promise<HealthStatus> {
    const checks = await Promise.allSettled([
      this.checkDatabase(),
      this.checkRedis(),
      this.checkMemoryUsage()
    ]);
    
    return {
      status: checks.every(check => check.status === 'fulfilled') ? 'healthy' : 'unhealthy',
      timestamp: new Date().toISOString(),
      checks: {
        database: checks[0].status,
        redis: checks[1].status,
        memory: checks[2].status
      }
    };
  }
}
```

## 変更履歴

| 日付 | 変更者 | 変更内容 |
|-----|-------|---------|
| 2025/06/08 | カーン | 初版作成 |
| 2025/06/09 | カーン | Level B標準構造適用（1-4章の構造統一） |
| 2025/06/09 | カーン | Level B標準構造完全適用（5-11章追加、11章構成への統一完了） |
